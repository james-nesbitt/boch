#!/bin/sh
#
# COMMAND: Build a new image[:version] for a project
#

builds_addpath()
{
  list_add "path_builds" "${1}"
}
builds_getpath()
{
  list_get "path_builds"
}

# path to a core folder that contains various docker image builds
builds_addpath "${path_manage}/builds"
# check any libraries already loaded for new builds
for library in `libraries_getlibraries`; do
  library="${library##*:}/builds"
  if [ -d "${library}" ]; then
    builds_addpath "${path_data}/builds"
  fi
done

# command help function
build_help()
{
  echo "
Build or destroy a project related docker image.

The intention with this command is to build the project specific
image, which will then be used as a base image for all project containers
This base image can then be forked into different version, for different
purposes.

Another use of the function is to build/rebuild/destroy one of the required
parent images, that are the basis of the project specific container.
If you keep all of your builds in a \${path_builds} folder, then they
can easily be built by passing the individual folder names to this command.

  -b|--build {build} : override the build, the path to the Dockerfile
    as a sub-path of the one of the build directories:
    ${path_builds}

  -d|--destroy : delete/destroy the image instead of building it

  -i|--image {image} : overrides settings image name for new image
  -v|--version {version} : overrides settings image version for new image

@NOTE the docker_build function uses \"latest\" as the default
  image version/tag.
"
  echo "Builds paths used in the system:"
  for build in `builds_getpath`; do
    echo " --> ${build}"
  done
  echo "Builds found in the system:"
  for build in `builds_list`; do
    echo " --> ${build##*/}"
  done
}

# command execute function
build_execute()
{
  # default build settings
  local image="${project_image}"
  local build="${project_image}"
  local version="${project_imageversion}"

  # build or destroy
  local action="build"

  # local flags
  local flags=""
  while [ $# -gt 0 ]
  do
    case "$1" in
      -b|--build)
        image="${2}"
        build="${2}"
        shift
        ;;
      -d|--destroy)
        action="destroy"
        ;;
      -f|--force)
        flags="${flags} --force"
        ;;
      -i|--image)
        image="${2}"
        shift
        ;;
      -v|--version)
        version="${2}"
        shift
        ;;
      *)
        echo >&2 "unknown flag $1 : build [-b|--build {build}}] [-d|--destroy] [-f|--force] [-i|--image {image}] [-v|--version {version}]"
        break;; # terminate while loop
    esac
    shift
  done

  # build on the flags (valid for both create and destroy)
  flags="${flags} --image ${image}"
  if [ -n "${version}" ]; then
    flags="${flags} --version ${version}"
  fi

  if [ "$action" == "destroy" ]; then    # test to see if the build exists
    build_destroy ${flags}
    return $?
  else
    local path="`build_find $build`"

    if [ -d ${path} ]; then
      build_build ${flags} --path "${path}"
      return $?
    fi

    # no matching build folder found anywhere
    debug --level 8 --topic "COMMAND->BUIlD->EXECUTE" "No matching build found [build:${build}]"
    return 1
  fi
}

# try to find a build in a build path
build_find()
{
  local build=$1
  local path=""

  # determine which build folder has the build
  for path_build in `builds_getpath`; do
    path="${path_build}/${build}"
    if [ -d ${path} ]; then
      echo "${path}"
    fi
  done
}

# destroy function
#
# @TODO add --force action: which would force it to be deleted
build_destroy()
{
  # don't force delete images by default
  local force=0

  # local flags
  local flags=""
  while [ $# -gt 0 ]
  do
    case "$1" in
      -f|--force)
        force=1
        flags="${flags} --force"
        ;;
      -i|--image)
        local image="${2}"
        flags="${flags} --image ${image}"
        shift
        ;;
      -v|--version)
        local version="${2}"
        flags="${flags} --version ${version}"
        shift
        ;;
      *)
        echo >&2 "unknown flag $1 : build_destroy [-f|--force] -i|--image {image} -v|--version {version}"
        break;; # terminate while loop
    esac
    shift
  done

  local tag="${image}"
  if [ -n "$version" ]; then
    tag="${tag}:${version}"
  fi

  if ! _docker_image_exists "${tag}"; then
    if [ $force -eq 0 ]; then
      debug --level 1 --topic "COMMAND->BUILD" "build_destroy() :: error destroying custom image, image doesn't exist: ${tag}"
    else
      debug --level 1 --topic "COMMAND->BUILD" "build_destroy() :: image doesn't exist, trying to delete anyway (because of --force): ${tag}"
    fi
  fi
  if ! _docker_image_running "${tag}"; then

    if [ $force -eq 0 ]; then
      debug --level 1 --topic "COMMAND->BUILD" "build_destroy() :: error destroying custom image, image has running containers: ${tag}"
    else
      debug --level 4 --topic "COMMAND->BUILD" "build_destroy() :: trying to destroy custom image that has running containers (because of --force): ${tag}"
    fi
  fi

  # run the rmi method
  debug --level 5 --topic "COMMAND->BUILD" "build_destroy() :: destroying custom image [ handing off to docker abstraction ] ==> docker_rmi ${flags}"
  docker_rmi ${flags}
  return $?
}

# build function
#
# @note --image and --version are optional, --path is required
build_build()
{
  # don't force buld existing images
  local force=0

  # local flags
  local flags=""
  while [ $# -gt 0 ]
  do
    case "$1" in
      -f|--force)
        force=1
        flags="${flags} --force"
        ;;
      -p|--path)
        local path="${2}"
        shift
        ;;
      -i|--image)
        local image="${2}"
        flags="${flags} --image ${image}"
        shift
        ;;
      -v|--version)
        local version="${2}"
        flags="${flags} --version ${version}"
        shift
        ;;
      *)
        echo >&2 "unknown flag $1 : build_build [-f|--force] -i|--image {image} -v|--version {version} -p|--path {path}"
        break;; # terminate while loop
    esac
    shift
  done

  local tag="${image}"
  if [ -z $version ]; then
    tag="${tag}:${version}"
  fi

  if _docker_image_exists "${tag}" ; then
    if [ $force -eq 0 ]; then
      debug --level 1 --topic "COMMAND->BUILD" "build_build() :: error building custom image, image already exists: ${tag}"
    else
      debug --level 4 --topic "COMMAND->BUILD" "build_build() :: image already exists, forcing build anyway due to force flag: ${tag}"
    fi
  fi

  # test to see if the build exists
  if [ ! -d ${path} ]; then
    debug --level 1 --topic "COMMAND->BUILD" "build_build() :: error building custom image, path to build doesn't exist: ${path}"
  fi

  # Run the build function
  debug --level 5 --topic "COMMAND->BUILD" "build_build() :: building custom image [ handing off to docker abstraction ] ==> docker_build ${flags} --path ${path}"
  docker_build ${flags} --path "${path}"
  return $?
}

builds_list()
{
  local builds_path
  local build_path
  for builds_path in `builds_getpath`; do
    for build_path in ${builds_path}/*; do
      if [ -d ${build_path} ]; then
        echo ${build_path}
      fi
    done
  done
}

build_find()
{
  local build=$1
  local path=::
  for path in `builds_list`; do
    if [ "${build}" == "${path##*/}" ]; then
      echo "${path}"
      return 0
    fi
  done
  return 1
}
