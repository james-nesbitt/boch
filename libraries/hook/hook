#!/bin/sh
#
# Hook related functionality
#

#
# Hooks
#
# Hooks are lists of function in particular paths, that are run in sequence
# in order to implement functionality.
#
# Hook Versions
#
# 1 : an inline script, without any _help or _execute methods
# 2 : a functional script with _help _description and _execute methods
#
# @TODO refactor to allow:
#   - sort of all hooks (based on state, across paths)
#   - allow hook exclusion

hooks_addpath()
{
  list_add "path_hooks" "${1}"
}
hooks_getpath()
{
  list_get "path_hooks"
}

# add this library hooks to the hooks path
# @note we need to do this manually, as these hooks do it for other libraries
hooks_addpath "${path_manage}/libraries/hook/hooks"


###
# Run hooks for a command
#
# Conceptually, the function arguments determine
# a number of paths, and all function in those
# paths are executed
#
# $1 : command
# -s|--state {state} : state e.g. pre or post
# $@ : passed to the hook functions
#

# path to a folder that has shell scripts which execute hooks for commands
# @NOTE this is a space delimited list of paths, executed in order
path_hooks="${path_hooks:-"${path_manage}/hooks"}"

#hook_root=""
#hook_version=""
hooks_execute()
{
  # string to capture list of hooks implemented
  local hook_list=""

  # method to run (on v2 and later hooks)
  local action="execute"

  # require the first argument to be the command
  local hook=$1
  shift

  # base hooks path
  local paths=""

  while [ $# -gt 0 ]
  do
    case "$1" in
      -a|--action)
        action="${2}"
        shift
        ;;
      -s|--state)
        hook="${hook}/${2}"
        shift
        ;;
      *)
          break;; # terminate while loop
    esac
    shift
  done

  # build paths from hooks path parent, and hook
  for path_parent in `hooks_getpath`; do
    paths="${paths} ${path_parent}/${hook}"
  done

  # loop through all of the paths and execute any functions found.
  debug --level 9 --topic "HOOKS->EXECUTE" "executing any hooks in these paths: ${paths}"
  local path=""
  local path_hook=""
  for path in ${paths}; do

    if [ -d ${path} ]; then
        for path_hook in ${path}/*; do

          # include and execute the hook
          if [ -f ${path_hook} ] && [ -x ${path_hook} ]; then

	    hook_execute $path_hook $@

	    if [ $? -gt 0 ]; then
	      debug --level 8 --topic "HOOKS->EXECUTE" "Hook return an error during execution [hook:${hook}][path:${path_hook}]"
	      return 1
	    fi
	  else
	    if [ -f ${path} ]; then
	      debug --level 7 --topic "HOOKS->EXECUTE" "Possible hook ignored, as it is not executable or not [hook:${hook}][path:${path_hook}]"
	    fi
	  fi
        done
    else
      debug --level 9 --topic "HOOKS->EXECUTE" "Hook path doesn't exist: ${path} $@"
    fi
  done
  if [ "${hooks_list}" != "" ]; then
    debug --level 8 --topic "HOOKS->EXECUTE" "executed hooks: ${hook_list}"
  fi
}

# List all hooks
hooks_list()
{
  # string to capture list of hooks implemented
  local hook_list=""

  # require the first argument to be the command
  local hook=$1
  shift

  # base hooks path
  local paths=""

  while [ $# -gt 0 ]
  do
    case "$1" in
      -s|--state)
        hook="${hook}/${2}"
        shift
        ;;
      *)
          break;; # terminate while loop
    esac
    shift
  done

  # build paths from hooks path parent, and hook
  for path_parent in `hooks_getpath`; do
    paths="${paths} ${path_parent}/${hook}"
  done

  # loop through all of the paths and execute any functions found.
  local path=""
  for path in ${paths}; do
    if [ -d ${path} ]; then
      for hook in ${path}/*; do
        if [ -f ${hook} ] && [ -x ${hook} ]; then
          hook_list="${hook_list} ${hook}"
        fi
      done
    fi
  done
  debug --level 9 --topic "HOOKS->LIST" "hooks list [hook:$hook] : $hook_list"
  echo "${hook_list}"
}

# included_hooks=""
# @NOTE Multiple hook include disabled, as it doesn't give us the correct setting of hook_version and hook_root
hook_include()
{
  local hook=$1
  shift

  # check if already attempted (if not mark it as attempted)
#   case " $included_hooks " in
#     *" ${hook} "*)
#         debug --level 7 --topic "HOOKS->INCLUDE" "hook_include [hook:${hook}][included_hooks:${included_hooks}] hook already included!"
#         return 1
#       ;;
#   esac
#   included_hooks="${included_hooks} ${hook}"

  if [ -f ${hook} ]; then

    debug --level 8 --topic "HOOKS->INCLUDE" "Including hook.  Handing off to _include_source [hook:${hook}] ==> _include_source \"${hook}\" $@ "
    _include_source "${hook}" $@
    local success=$?
    if [ $success -eq 0 ]; then
      debug --level 7 --topic "HOOKS->INCLUDE" "hook included \"${hook}\""
    else
      debug --level 4 --topic "HOOKS->INCLUDE->FAIL" "hook include failed for \"${hook}\""
    fi

  else

    debug --level 6 --topic "HOOKS->INCLUDE->FAIL" "Hook could not be included as it was not found, or is not a file [hook:${hook}]"

  fi

  return $sucess
}

# execute a hook method
hook_execute()
{
  # hook is the first param
  local hook="$1"
  shift

  debug --level 9 --topic "HOOKS->EXECUTE" "hook_execute [hook:${hook}]: START"

  # default action
  local action="execute"

  while [ $# -gt 0 ]
  do
    case "$1" in
      -a|--action)
        action=$2
        shift
        ;;
      *)
          break;; # terminate while loop
    esac
    shift
  done

  # clear out version and root vars so that the hook file can define them
  hook_version=""
  hook_root=""

  # include hook - capture the output, as this may be an older version hook
  hook_include ${hook}

  debug --level 8 --topic "HOOKS->EXECUTE" "Included and Executing Hook script (source) [hook:$hook][hook_root:${hook_root}][hook_version:${hook_version}][args:$@]"

  # if the hook source set a hook_version, then react to the version
  case "$hook_version" in
    2)
      # version 2 hooks have methods named after the actions
      local hook_function="${hook_root}_${action}"
      debug --level 8 --topic "HOOKS->EXECUTE" "Executing Hook script (source) [action:$action][hook_version:${hook_version}][hook_root:${hook_root}][hook_function:${hook_function}]: ${hook_function} $@"
      eval ${hook_function} $@

      if [ $? -gt 0 ]; then
        debug --level 7 --topic "HOOKS->EXECUTE" "Hook script return an error [hook:$hook][hook_function:${hook_function}]: ${hook_function} $@"
        return 1
      else
        debug --level 6 --topic "HOOKS->EXECUTE" "Hook script executed [hook:$hook][hook_function:${hook_function}]: ${hook_function} $@"
        return 0
      fi
      ;;
    *)
      # older version hooks execute inline.  they have only the execute action.
      debug --level 6 --topic "HOOKS->EXECUTE" "this hook source exists, but did not define any version.  Is this an older version hookfile? [hook:$hook][hook_version:${hook_function}]"
      return 1
      ;;
  esac

}

# create a usable short label for a hook
hook_label()
{
  local hook=$1

  echo ${hook##*/}
}

# show the description hook echo for a hook
hook_description()
{
  local hook=$1
  shift

  hook_execute ${hook} --action "description" $@
}
# show the help contents for a hook
hook_help()
{
  local hook=$1
  shift

  hook_execute ${hook} --action "help" $@
}
