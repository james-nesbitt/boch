#!/bin/sh

# Common control
vflag=off
# DEBUG : output debugging text
debug=0

# Some hardcoded stuff to let us call the script from elsewhere
# path executed from
path_execution="`pwd`"
# path to the root of this project
path_project="$(dirname $( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd))"
# path to user home folder (in case)
path_userhome="${HOME}"
# path to this management system
path_manage="$path_project/manage"
# path to a shell script that will be allowed to override some of these settings
path_settings="$path_manage/_settings.sh"
# path to a folder that has shell scripts which execute commands
path_commands="${path_manage}/commands"
# path to a folder that has shell scripts which execute hooks for commands
path_hooks="${path_manage}/hooks"
# path to a folder where the system can keep some data
path_data="${path_manage}/data"
# path to a folder that contains various docker image builds
path_build="${path_manage}/build"

# Include utility functions
source ${path_manage}/_utilities.sh
# include docker functions - bash abstractions for docker operations
source ${path_manage}/_docker.sh

# Each docker container has a unique name - currently
# we are tracking only a signle container, and it's
# name is kept in a single file..  This limited use
# should be expanded to give some kind of db of names
# to provide different development tools.
# This should lead to an entire system of versioning
# and forking.
#
# A path to a file that containers the current Container name
# (edit this if you want to rebase, or override ${Docker_containerID} in settings.sh)
path_containter="$path_data/_container"
# What is the container Name or mini-ID for the latest container
Docker_container=""
if [ -f ${path_container} -a -s ${path_container} ]; then
  Docker_container="`cat ${path_containter}`"
fi
# this function is called whenever a container is started
Docker_container_save_callback="_container_save"
Docker_container_empty_callback="_container_empty"

# include docker setting overrides
# In this settings.sh file you can include all sorts of variable overrides.
source ${path_manage}/_settings.sh

# Overridable settings for docker and the machine
# these are here because they tend to depend on each
# other, and you may want to override one of the top
# items, and let the rest be based on it.

# General project name, should be file-safe
Project_name="${Project_name:-${path_project##*/}}"

# The docker image, which will be used for containers, (and building)
Docker_image="${Docker_image:-$Project_name}"
# by default all containers will run from the base image, which is created by build, however maybe we want to use a different version for advanced features
Docker_imageversion="${Docker_imageversion:-"latest"}" # Used for run/shell/commit
# Parent image name, used for image build and parent image build (but not used for most operations)
Docker_parentimage="${Docker_parentimage:-"wwwserver-cnpm-dev"}"
# use a default container name, default to a combination of image and version
Docker_container=${Docker_container:-${Docker_image}_${Docker_imageversion}}

# Default running ar
Machine_runargs=${Machine_runargs:-"--tty"}
# hostname used inside the running container
Machine_hostname="${Machine_hostname:-$Docker_container}"
# live mounts that are used for containers
Machine_mountvolumes="${Machine_mountvolumes} --volume=${path_project}/source:/app/source"
# Prefered shell/command for the Machine
Machine_shell=${Machine_shell:-"/bin/bash"}
Machine_shellrunargs=${Machine_shellrunargs:-"--publish-all=true"}

#
# Process Global Arguments and find the COMMAND
#
while [ $# -gt 0 ]
do
  case "$1" in
    -v|--verbose)  
      vflag=on
      debug=1
      ;;
    -*)
        echo >&2 "usage: $0 [-v|--verbose] [command ...].  Try \"help\" for more instructions."
        exit 1;;
    *)
        break;; # terminate while loop
  esac
  shift
done

#
# Determine what command is supposed to be run
#
# the first non-hyphenated argument is the command
COMMAND=$1
shift

# Maybe print some debug info
if [ "$debug" == "1" ]; then
  echo "
CONTROL: DEBUG MODE ENABLED
CONTROL: final control settings: [
PATHS USED
-->path_project:${path_project}
-->path_execution:${path_execution}
-->path_build:${path_build}
-->path_manage:${path_manage}
-->path_commands:${path_commands}
-->path_hooks:${path_hooks}
-->path_settings:${path_settings}
-->path_data:${path_data}
DOCKER CONFIGURATIONS
-->Docker_container:${Docker_container}
-->Docker_image:${Docker_image}
-->Docker_imageversion:${Docker_imageversion}
-->Docker_parentimage:${Docker_parentimage}
MACHINE CONFIGURATIONS
-->Machine_hostname:${Machine_hostname}
-->Machine_mountvolumes:${Machine_mountvolumes}
-->Machine_shell:${Machine_shell}
-->Machine_shellrunargs:${Machine_shellrunargs}
-->Machine_runargs:${Machine_runargs}
CONTAINER SAVE:
-->path_containter:${path_containter}
-->Docker_container_save_callback:${Docker_container_save_callback}
-->Docker_container_empty_callback:${Docker_container_empty_callback}
COMMAND TO BE EXECUTED
-->Command:${COMMAND}
-->Command Args:${@}
]"
fi

#
# Process command : pass the rest of the arguments to the command
#

# determine the file that should execute for the command
command_file="${path_commands}/${COMMAND}.sh"
if [ -f ${command_file} ]; then

  #command function to call
  command_function="${COMMAND}_execute"

  # We have a command file, so we hand the execution off to
  # that script to run inline (not as a function)
  debug "CONTROL: command [ ${COMMAND} ] handing off to command script : ${command_file}::${command_function}"
  source ${command_file}
  eval ${command_function} $@

else 
  # no command was found
  echo "CONTROL: Unknown command \"${COMMAND}' - try using 'control help' for instructions."      
fi
