#!/bin/sh
#
# Central container control script
#

##################
# Common control #
##################
vflag=off
# DEBUG : output debugging text
debug=0

#####################
# Some reused paths #
#####################
# path executed from
path_execution="`pwd`"
# path to the root of this project
path_project="$(dirname $( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd))"
# path to user home folder (in case)
path_userhome="${HOME}"
# path to this management system
path_manage="$path_project/manage"
# path to a shell script that will be allowed to override some of these settings
path_settings="$path_manage/_settings.sh"
# path to a folder that has shell scripts which execute commands
path_commands="${path_manage}/commands"
# path to a folder that has shell scripts which execute hooks for commands
path_hooks="${path_manage}/hooks"
# path to a folder where the system can keep some data
path_data="${path_manage}/data"
# path to a folder that contains various docker image builds
path_build="${path_manage}/build"

# Include utility functions
source ${path_manage}/_utilities.sh
# include docker functions - bash abstractions for docker operations
source ${path_manage}/_docker.sh

#################################################
# Process Global Arguments and find the COMMAND #
#################################################
# so far we only have 1 global argument

while [ $# -gt 0 ]
do
  case "$1" in
    -v|--verbose)  
      vflag=on
      # if an integer level was passed, take it, otherwise default to 5
      if [ -n "$2" ] && [ -z "${2##[0-9]}" ]; then
        debug=${2}
        shift
      else
        debug=5
      fi
      debug --topic "CONTROL" "Debug mode enabled (level:${debug})"
      ;;
    -*)
        echo >&2 "usage: $0 [-v|--verbose] [command ...].  Try \"help\" for more instructions."
        exit 1;;
    *)
        break;; # terminate while loop
  esac
  shift
done

#######################################
# Docker saving active container conf #
#######################################
# Each docker container has a unique name - currently
# we are tracking only a signle container, and it's
# name is kept in a single file..  This limited use
# should be expanded to give some kind of db of names
# to provide different development tools.
# This should lead to an entire system of versioning
# and forking.
#
# A path to a file that containers the current Container name
# (edit this if you want to rebase, or override ${Docker_containerID} in settings.sh)
path_container="$path_data/_container"
# What is the container Name or mini-ID for the latest container
Docker_container=""

####################################
# include docker setting overrides #
####################################

# execute any existing settings hooks
#debug "CONTROL: Running settings hooks => hooks_execute settings"
hooks_execute settings

###################################################
# Overridable settings for docker and the machine #
###################################################
# these are here because they tend to depend on each
# other, and you may want to override one of the top
# items, and let the rest be based on it.

# General project name, should be file-safe
Project_name="${Project_name:-${path_project##*/}}"

# The docker image, which will be used for containers, (and building)
Docker_image="${Docker_image:-$Project_name}"
# by default all containers will run from the base image, which is created by build, however maybe we want to use a different version for advanced features
Docker_imageversion="${Docker_imageversion:-"latest"}" # Used for run/shell/commit
# Parent image name, used for image build and parent image build (but not used for most operations)
Docker_parentimage="${Docker_parentimage:-"wwwserver-cnpm-dev"}"
# use a default container name, default to a combination of image and version
Docker_container=${Docker_container:-${Docker_image}_${Docker_imageversion}}

# Default running args
Machine_runargs=${Machine_runargs:-"--tty"}
# hostname used inside the running container
Machine_hostname="${Machine_hostname:-$Docker_container}"
# live mounts that are used for containers
Machine_mountvolumes="${Machine_mountvolumes} --volume=${path_project}/source:/app/source"
# Prefered shell/command for the Machine
Machine_shell=${Machine_shell:-"/bin/bash"}
# default run args for shell command
Machine_shellrunargs=${Machine_shellrunargs:-"--publish-all=true"}

################################################
# Determine what command is supposed to be run #
################################################
# the first non-hyphenated argument is the command
COMMAND=$1
shift

# Maybe print some debug info (debug command loses carriage returns, so we echo ourselves)
if [ "$debug" == "1" ]; then
  echo "
CONTROL: final control settings: [
  >PATHS USED
  -->path_project:${path_project}
  -->path_execution:${path_execution}
  -->path_build:${path_build}
  -->path_manage:${path_manage}
  -->path_commands:${path_commands}
  -->path_hooks:${path_hooks}
  -->path_settings:${path_settings}
  -->path_data:${path_data}
  >DOCKER CONFIGURATIONS
  -->Docker_container:${Docker_container}
  -->Docker_image:${Docker_image}
  -->Docker_imageversion:${Docker_imageversion}
  -->Docker_parentimage:${Docker_parentimage}
  >MACHINE CONFIGURATIONS
  -->Machine_hostname:${Machine_hostname}
  -->Machine_mountvolumes:${Machine_mountvolumes}
  -->Machine_shell:${Machine_shell}
  -->Machine_shellrunargs:${Machine_shellrunargs}
  -->Machine_runargs:${Machine_runargs}
  >CONTAINER SAVE:
  -->path_container:${path_container}
  >COMMAND TO BE EXECUTED
  -->Command:${COMMAND}
  -->Command Args:${@}
]"
fi

###################################################################
# Process command : pass the rest of the arguments to the command #
###################################################################

# determine the file that should execute for the command
command_file="${path_commands}/${COMMAND}.sh"
if [ -f ${command_file} ]; then

  #command function to call
  command_function="${COMMAND}_execute"

  # execute any existing pre hooks
  #debug "CONTROL: Running global:pre hooks => hooks_execute global --state \"pre\" --command \"${COMMAND}\""
  hooks_execute command --state "pre" --command "${COMMAND} $@"

  # We have a command file, so we hand the execution off to
  # that script to run inline (not as a function)
  debug --level 4 --topic "CONTROL" "command [ ${COMMAND} ] handing off to command script : ${command_file}::${command_function}"
  source ${command_file}
  eval ${command_function} $@

  # execute any existing post hooks
  #debug "CONTROL: Running global:post hooks => hooks_execute global --state \"post\" --command \"${COMMAND}\""
  hooks_execute command --state "post" --command "${COMMAND} $@"

else 
  # no command was found
  echo "CONTROL: Unknown command \"${COMMAND}' - try using 'control help' for instructions."      
fi
