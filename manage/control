#!/bin/sh

# Some hardcoded stuff to let us call the script from elsewhee
path_project="$(dirname $( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd))"
#
# get some paths
#
path_manage="$path_project/manage"
path_settings="$path_manage/_settings.sh"
# Give paths to the docker build
# (the parent is the docker parent image build, which should be built outside of this tool)
path_build="${path_manage}/docker"
path_buildparent="${path_manage}/dockerparent"
# A path to a file that containers the current ContainerID
# (edit this if you want to rebase, or override ${Docker_container} in settings.sh)
path_containterID="$path_manage/_container"

# Comman control
vflag=off
debug=0

# include docker setting overrides
source ${path_manage}/_settings.sh
# Overridable settings for docker and the machine
# these are here because they tend to depend on each
# other, and you may want to override one of the top
# items, and let the rest be based on it.
# General name, should be file-safe
Project_name="${Project_name:-${path_project##*/}}"
# The docker image, which will be used for containers, (and building)
Docker_image="${Docker_image:-$Project_name}"
# by default all containers will run from the base image, which is created by build, however maybe we want to use a different version for advanced features
Docker_imageversion="${Docker_imageversion:-"base"}"

# Parent image name, used for image build and parent image build (but not used for most operations)
Docker_parentimage="${Docker_parentimage:-"wwwserver-cpnm-dev"}"

# What is the
[ -z "${Docker_container}" ] && Docker_container="`cat ${path_containterID}`"
# hostname used inside the running container
Machine_hostname="${Machine_hostname:-$Docker_container}"

# include docker functions - bash abstractions for docker operations
source ${path_manage}/_docker.sh

#
# Process Global Arguments and find the COMMAND
#
while [ $# -gt 0 ]
do
  case "$1" in
    -v|--verbose)  vflag=on; debug=1;;
    -*)
        echo >&2 "usage: $0 [-v] [command ...]"
        exit 1;;
    *)
        break;; # terminate while loop
  esac
  shift
done

# the first non-hyphenated argument is the command
COMMAND=$1
shift

# Maybe print some debug info
if [ "$debug" == "1" ]; then
  echo "FINAL SETTINGS:"
  echo "path_project:${path_project}"
  echo "path_execution:${path_execution}"
  echo "path_build:${path_build}"
  echo "path_buildparent:${path_buildparent}"
  echo "path_manage:${path_manage}"
  echo "path_settings:${path_settings}"
  echo "path_containterID:${path_containterID}"
  echo "Docker_container:${Docker_container}"
  echo "Docker_image:${Docker_image}"
  echo "Docker_parentimage:${Docker_parentimage}"
  echo "Machine_hostname:${Machine_hostname}"
  echo "Command:${COMMAND}"
  echo "Command Args:${@}"
fi

#
# Process command : pass the rest of the arguments in
#
case "$COMMAND" in
    build)
      # build the project docker image, from the docker build file
      # located in the docker build directory.
      #
      # --p|--parent : build parent before building this parent
      #
      # @TODO - build the parent if it is not found, instead of using the flag!
      #
      while [ $# -gt 0 ]
      do
        case "$1" in
          -p|--parent)
            # Run the build function for the parent first (no version used for this)
            docker_build "${path_buildparent}" "${Docker_parentimage}"
            ;;
          *)
            echo >&2 "unknown flag $1 : build [-p|--parent]"
            break;; # terminate while loop
        esac
        shift
      done

      # Run the build function
      docker_build "${path_build}" "${Docker_image}" "${Docker_imageversion}"
      ;;

    start)
      # Start a new container based on the image.

      # Run the start function
      docker_start $@
      ;;

    stop)
      # Stop the container if it is running

      # Run the stop function
      docker_stop $@
      ;;

    shell)
      # Give shell access to a new container based on the image
      # this does not term into a running container, but rather
      # creates a new container and gives shell access to it

      # Run the shell function
      docker_shell $@
      ;;

esac