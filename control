#!/bin/sh
#
# Central container control script
#

##################
# Common control #
##################
vflag=off
# DEBUG : output debugging text
debug=3
# DEBUG : Logging level
log=0
# Execution date & time (mainly used for logging)
date="`date +%F/%H:%m.%S`"
# Unique identifer of execution (random number)
#executionid="`echo ${date} | md5sum`"
executionid="${RANDOM}"

#####################
# Some reused paths #
#####################
# path executed from
path_execution="`pwd`"
# path to this management system
path_manage="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"
# path to the root of this project
path_project="$(dirname ${path_manage})"
# path to user home folder (in case)
path_userhome="${HOME}"
# path to this management system
path_settings="$path_project/settings.sh"
# path to a shell script that will be allowed to override some of these settings
path_commands="${path_manage}/commands"
# path to a folder that has shell scripts which execute hooks for commands
path_hooks="${path_manage}/hooks"
# path to a folder where the system can keep some data
path_data="${path_manage}/data"
# path to a folder that contains various docker image builds
path_build="${path_manage}/build"
# path to the log file
path_log="${path_data}/log"

# Include utility functions
source ${path_manage}/_utilities.sh
# include docker functions - bash abstractions for docker operations
source ${path_manage}/_docker.sh

#################################################
# Process Global Arguments and find the COMMAND #
#################################################
#
# -v|--verbose {level} : output debugging info
# -l|--log {level} : enable debug logging
# -f|--force : ignore critical errors (don't halt)
#

while [ $# -gt 0 ]
do
  case "$1" in
    -v|--verbose)
      vflag=on
      # if an integer level was passed, take it, otherwise default to 5
      if [ -n "$2" ] && [ -z "${2##[0-9]}" ]; then
        debug=${2}
        shift
      else
        debug=5
      fi
      debug --level 3 --topic "CONTROL" "Debug mode enabled (level:${debug})"
      ;;
    -l|--log)
      # if an integer level was passed, take it, otherwise default to 8
      if [ -n "$2" ] && [ -z "${2##[0-9]}" ]; then
        log=${2}
        shift
      else
        log=8
      fi
      debug --level 3 --topic "CONTROL" "Logging mode enabled (level:${log})"
      ;;
    -f|--force)
      # lower the critical error level so that errors don't halt
      _debug_critical_level=0
      debug --level 3 --topic "CONTROL" "Forced mode enabled"
      ;;
    -*)
        echo >&2 "usage: $0 [-v|--verbose] [command ...].  Try \"help\" for more instructions."
        exit 1;;
    *)
        break;; # terminate while loop
  esac
  shift
done

#######################################
# Docker saving active container conf #
#######################################
# Each docker container has a unique name - currently
# we are tracking only a signle container, and it's
# name is kept in a single file..  This limited use
# should be expanded to give some kind of db of names
# to provide different development tools.
# This should lead to an entire system of versioning
# and forking.
#
# A path to a file that containers the current Container name
# (edit this if you want to rebase, or override ${Docker_containerID} in settings.sh)
path_container="$path_data/_container"
# What is the container Name or mini-ID for the latest container
Docker_container=""

####################################
# include docker setting overrides #
####################################

# execute any existing settings hooks
debug --level 7 --topic "CONTROL" "Running settings hooks => hooks_execute settings"
hooks_execute settings --state pre
hooks_execute settings
hooks_execute settings --state post

###################################################
# Overridable settings for docker and the machine #
###################################################
# these are here because they tend to depend on each
# other, and you may want to override one of the top
# items, and let the rest be based on it.

# General project name, should be file-safe
Project_name="${Project_name:-${path_project##*/}}"

# Docker build images
# Generally needed to start making containers (a space separated queue of builds)
# and are the ddefault builds built with the build command.
Docker_builds="${Docker_builds:-"wwwserver-cnpm wwwserver-cnpm-dev project"}"
# The docker image, which will be used for containers, (and building)
Docker_image="${Docker_image:-${Docker_builds##* }}"
# by default all containers will run from the base image, which is created by build, however maybe we want to use a different version for advanced features
Docker_imageversion="${Docker_imageversion:-"latest"}" # Used for run/shell/commit
# use a default container name, default to a combination of image and version
Docker_container=${Docker_container:-${Docker_image}_${Docker_imageversion}}

# Default running args
Machine_runargs=${Machine_runargs:-""}
# hostname used inside the running container
Machine_hostname="${Machine_hostname:-$Docker_container}"
# live mounts that are used for containers
Machine_mountvolumes="${Machine_mountvolumes} --volume=${path_project}/source:/app/source"
# Prefered shell/command for the Machine
Machine_shell=${Machine_shell:-"/bin/bash"}
# default run args for shell command
Machine_shellrunargs=${Machine_shellrunargs:-"--publish-all=true"}

################################################
# Determine what command is supposed to be run #
################################################
# the first non-hyphenated argument is the command
COMMAND=$1
shift

# Maybe print some debug info (debug command loses carriage returns, so we echo ourselves)
if [ $debug -gt 3 ]; then
  echo "
CONTROL: final control settings: [
  >PATHS USED
  -->path_project:${path_project}
  -->path_execution:${path_execution}
  -->path_manage:${path_manage}
  -->path_settings:${path_settings}
  -->path_build:${path_build}
  -->path_commands:${path_commands}
  -->path_hooks:${path_hooks}
  -->path_data:${path_data}
  >PROJECT CONFIGURATION
  -->Project_name:${Project_name}
  >DOCKER CONFIGURATIONS
  -->Docker_container:${Docker_container}
  -->Docker_builds:${Docker_builds}
  -->Docker_image:${Docker_image}
  -->Docker_imageversion:${Docker_imageversion}
  >MACHINE CONFIGURATIONS
  -->Machine_hostname:${Machine_hostname}
  -->Machine_mountvolumes:${Machine_mountvolumes}
  -->Machine_shell:${Machine_shell}
  -->Machine_shellrunargs:${Machine_shellrunargs}
  -->Machine_runargs:${Machine_runargs}
  >CONTAINER SAVE:
  -->path_container:${path_container}
  >COMMAND TO BE EXECUTED
  -->Command:${COMMAND}
  -->Command Args:${@}
]"
fi

###################################################################
# Process command : pass the rest of the arguments to the command #
###################################################################

# We have a command file, so we hand the execution off to
# that script to run inline (not as a function)
if _include_command ${COMMAND}; then

  # execute any existing pre hooks
  debug --level 7 --topic "CONTROL" "Running global:pre hooks => hooks_execute global --state \"pre\" --command \"${COMMAND}\""
  hooks_execute command --state "pre" --command "${COMMAND} $@"

  command_function="${COMMAND}_execute"
  debug --level 4 --topic "CONTROL" "command [ ${COMMAND} ] handing off to command script : ${command_function}"
  eval ${command_function} $@
  success=$?
  if [ $success == 0 ]; then
    echo "$result"
    debug --level 6 --topic "CONTROL" "${COMMAND} succeeded."

    # execute any existing post hooks
    debug --level 7 --topic "CONTROL" "Running global:post hooks => hooks_execute global --state \"post\" --command \"${COMMAND}\""
    hooks_execute command --state "post" --command "${COMMAND} $@"
  else
    debug --level 2 --topic "CONTROL" "Command execution failed for command ${COMMAND}."

    # execute any existing post hooks
    debug --level 7 --topic "CONTROL" "Running global:post hooks => hooks_execute global --state \"fail\" --command \"${COMMAND}\""
    hooks_execute command --state "fail" --command "${COMMAND} $@"
  fi
  exit $sucess

else
  # no command was found
  debug --level 4 --topic "CONTROL" "${COMMAND} failed.  Unkown command."
  echo "CONTROL: Unknown command \"${COMMAND}' - try using 'control help' for instructions."
fi
