#!/bin/sh

#######################################
# some timing and debug related stuff #
#######################################

# Execution date & time (mainly used for logging)
date="`date +%F/%H:%m.%S`"
# Unique identifer of execution (random number)
#executionid="`echo ${date} | md5sum`"
executionid="${RANDOM}"

##################
# Common control #
##################

vflag=off
# DEBUG : default debugging level (3 gives some minimal output)
debug=${debug:-3}
# DEBUG : Logging level (same as debug, but for the log file)
log=${log:-0}

#####################
# Some reused paths #
#####################
#
# Feel free to change any of these paths
# but note that a lot of other paths may
# de based on them
#

# Subpath of a root project folder, that container project configuration
subpath_project="project"

# path executed from
path_execution="`pwd`"
# path to user home folder (in case)
path_userhome="${HOME}"

# Determine project root, and data paths
path_project="${path_execution}"
while [ -n "${path_project}" ] && [ "${path_project}" != "/" ]; do
  if [ -d "${path_project}/${subpath_project}" ]; then
    path_data="${path_project}/${subpath_project}"
    #echo "DISCOVERED PATHS [project:${path_project}][data:${path_data}]"
    break 2
  fi
  path_project="$(dirname "${path_project}")"
done
# If we didn't find a project path, then take the EXEC path as the project path
if [ -z "${path_project}" ] || [ "${path_project}" == "/" ]; then
  path_project="${path_execution}"
  # this data path will likely be empty, but this might be desirable for cases like flow init
  path_data="${path_project}/${subpath_project}"
#   echo "DEFAULT PATHS [project:${path_project}][data:${path_data}]"
fi

# path to this library
if [ -z "${path_manage}" ]; then
  if [ -d "${path_project}/manage" ]; then
    path_manage="${path_project}/manage"
  else
    path_manage="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"
  fi
fi

# Include utility functions (including the debug function)
source "${path_manage}/_utilities"
# Include library handling functions (including the library_load function)
source "${path_manage}/_libraries"

debug --level 7 --topic "INIT" "INCLUDING LIBRARIES"

# include utility functions for running hooks (which every other library relies on)
library_load "hook"

# include the settings library (with a tool to load settings from libraries that are not yet loaded)
library_load "settings"

# include help related functions (not debug, which is in utilities to get it loaded early.)
library_load "help"
# include docker functions - bash abstractions for docker operations
library_load "docker"
# include command related functions
library_load "command"

# include command related functions
library_load "www-builds"

# Maybe output some variabe settings
# @NOTE we do it like this because the debug command won't keep newlines in output
if [ $debug -gt 3 ]; then
  echo "
CONFIG: control settings after system initialization (can be modified after this point): [
  >SINGLE PATHS USED
  -->path_project----------: ${path_project}
  -->path_execution--------: ${path_execution}
  -->path_manage-----------: ${path_manage}
  -->path_data-------------: ${path_data}
  -->path_source-----------: ${path_source}
  >LIBRARIES
  -->libraries loaded------: `libraries_list`
  >HOOKS
  -->path_hooks------------: `hooks_getpath`
  >PROJECT CONFIGURATION
  -->Project_name----------: ${project_name}
  >PROJECT DOCKER CONFIGURATIONS
  -->project_container-----: ${project_container}
  -->project_image---------: ${project_image}
  -->project_imageversion--: ${project_imageversion}
  >PROJECT MACHINE CONFIGURATIONS
  -->Machine_hostname------: ${machine_hostname}
  -->Machine_mountvolumes--: `settings_mount_getmounts --short`
  -->Machine_shell---------: ${machine_shell}
  -->Machine_shellrunargs--: ${machine_shellrunargs}
  -->Machine_runargs-------: ${machine_runargs}
] (hooks/settings/post/950)"
fi

debug --level 7 --topic "INIT" "INCLUDING LIBRARIES COMPLETE"
